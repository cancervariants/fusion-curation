import { React, useState, useEffect } from 'react';
import { Box, TextField } from '@material-ui/core';

const ResponseField = ({
  responseJSON, setResponseJSON, responseHuman, setResponseHuman, components, proteinCoding,
  rfPreserved, domains, causativeEventKnown, causativeEvent, regulatoryElements, geneIndex,
  domainIndex, exonIndex,
}) => {
  /**
   * Transform computable fusion object into human-readable string
   * Uses 'hgvs-like' syntax, eg:
   *  NM_152263.2(EPCAM):exon5::NM_002609.3(MSH2):exon2
   *  NM_162263.2(TPM3):exon8::NM_002609.3(PDGFRB):exon11
   * TODO
   *  * CONSIDERABLY more logical detail is needed due to the change from
   *    'junctions' to 'components'
   *  * 'long form' syntax handling
   *  * how differing levels of specificity should be handled
   * @param {Object} outputJSON fusion object generated by handleSubmit()
   * @return {string} fusion object structured as human-readable string
   */
  const outputToReadable = (outputJSON) => {
    const jsonComponents = outputJSON.transcript_components;
    if (jsonComponents.length > 2) {
      const beginning = jsonComponents[0];
      const end = jsonComponents[jsonComponents.length - 1];

      // check for valid fields
      if (!('transcript' in beginning && 'gene' in beginning && 'symbol' in beginning.gene && 'exon_end' in beginning)) {
        return '';
      }
      if (!('transcript' in end && 'gene' in end && 'symbol' in end.gene && 'exon_start' in end)) {
        return '';
      }

      const beginningString = `${beginning.transcript}(${beginning.gene.symbol}):exon${beginning.exon_end}`;
      const endString = `${end.transcript}(${end.gene.symbol}):exon${end.exon_start}`;

      return `${beginningString}::${endString}`;
    }
    return '';
  };

  /**
   * Create transcript_segment object given user input
   * @param {Object} component object corresponding to given component, as stored in state and
   *  filled out by user
   * @param {number} index location in state array - used to infer some coordinate defaults
   * @returns complete transcript_segment object
   */
  const transcriptSegmentToJSON = (component, index) => {
    const out = { component_type: 'transcript_segment' };
    const values = component.componentValues;
    if ('transcript' in values) out.transcript = values.transcript;
    if ('gene_symbol' in values) {
      const symbol = values.gene_symbol;
      out.gene = {
        type: 'GeneDescriptor',
        symbol,
        id: geneIndex[symbol],
      };
    }

    if ((!out.gene) && (values.transcript in exonIndex) && (typeof exonIndex[values.transcript].geneSymbol !== 'undefined')) {
      const symbol = exonIndex[values.transcript].geneSymbol;
      const geneID = geneIndex[symbol];
      out.gene = {
        symbol,
        id: geneID,
      };
    }

    if (values.exon_end && values.exon_end !== '') {
      if (index === 0) {
        out.exon_start = exonIndex[values.transcript].exonStart;
        out.exon_start_genomic = {
          chr: exonIndex[values.transcript].chr,
          pos: exonIndex[values.transcript].start,
        };
      }
      out.exon_end = exonIndex[values.transcript].exonEnd;
      out.exon_end_genomic = {
        chr: exonIndex[values.transcript].chr,
        pos: exonIndex[values.transcript].end,
      };
      if (values.exon_end_offset && values.exon_end_offset !== '') {
        out.exon_end_offset = parseInt(values.exon_end_offset, 10);
      }
    }
    if (values.exon_start && values.exon_start !== '') {
      if (index === components.length - 1) {
        out.exon_end = exonIndex[values.transcript].exonEnd;
        out.exon_end_genomic = {
          chr: exonIndex[values.transcript].chr,
          pos: exonIndex[values.transcript].end,
        };
      }
      if (index !== 0) {
        out.exon_start = exonIndex[values.transcript].exonStart;
        out.exon_start_genomic = {
          chr: exonIndex[values.transcript].chr,
          pos: exonIndex[values.transcript].start,
        };
      }
      if (values.exon_start_offset && values.exon_start_offset !== '') {
        out.exon_start_offset = parseInt(values.exon_start_offset, 10);
      }
    }
    return out;
  };

  /**
   * Create genomic_region object given user input
   * @param {Object} component object corresponding to given component, as stored in state and
   *  filled out by user
   * @returns complete genomic_region object
   */
  const genomicRegionToJSON = (component) => {
    const out = {};
    const values = component.componentValues;
    if ('chr' in values) out.chr = values.chr;
    if ('strand' in values) out.strand = values.strand;
    if ('start_pos' in values) out.start_pos = values.start_pos;
    if ('end_pos' in values) out.end_pos = values.end_pos;

    return out;
  };

  /**
   * Create linker_sequence object given user input
   * @param {Object} component object corresponding to given component, as stored in state and
   *  filled out by user
   * @returns complete linker_sequence object
   */
  const linkerSequenceToJSON = (comp) => (
    {
      sequence: comp.componentValues.sequence,
    }
  );

  /**
   * Create gene object given user input
   * @param {Object} component object corresponding to given component, as stored in state and
   *  filled out by user
   * @returns complete gene object
   */
  const geneToJSON = (comp) => (
    {
      symbol: comp.componentValues.gene_symbol,
      id: geneIndex[comp.componentValues.gene_symbol],
    }
  );

  /**
   * Create unknown_gene component object given user input
   * @param {Object} component object corresponding to given component, as stored in state and
   *  filled out by user
   * @returns complete unknown_gene object
   */
  const unknownToJSON = (component) => {
    const output = {
      component_type: 'unknown_gene',
    };
    if (component.chr) output.chr = component.chr;
    if (component.start) output.start = component.start;
    if (component.end) output.end = component.end;
    return output;
  };

  /**
   * Generate response objects.
   * Should trigger upon changes in any user-supplied value (ie, not any AJAX-generated/computed
   *  fields)
   */
  useEffect(() => {
    // set JSON
    const jsonOutput = {};

    // functional domains
    if (proteinCoding === 'Yes') {
      if (rfPreserved === 'Yes') {
        jsonOutput.r_frame_preserved = true;
        if (domains.length > 0) {
          jsonOutput.protein_domains = domains.map((domain) => {
            const domainObject = {
              status: domain.status,
              name: domain.name,
            };
            if (domain.name) {
              domainObject.id = domainIndex[domain.name];
            }
            if (domain.gene) {
              domainObject.gene = {
                symbol: domain.gene,
                id: geneIndex[domain.gene],
              };
            }
            return domainObject;
          });
        }
      } else if (rfPreserved === 'No') {
        jsonOutput.r_frame_preserved = false;
      }
    }

    // transcript components
    jsonOutput.transcript_components = components.map((comp, index) => {
      if (comp.componentType === 'transcript_segment') {
        return transcriptSegmentToJSON(comp, index);
      }
      if (comp.componentType === 'genomic_region') {
        return genomicRegionToJSON(comp);
      }
      if (comp.componentType === 'linker_sequence') {
        return linkerSequenceToJSON(comp);
      }
      if (comp.componentType === 'gene') {
        return geneToJSON(comp);
      }
      if (comp.componentType === 'unknown_gene') {
        return unknownToJSON(comp);
      }
      return null;
    });

    // causative event
    if (causativeEventKnown === 'Yes') {
      jsonOutput.causative_event = {
        event_type: causativeEvent,
      };
    }

    // regulatory elements
    if (regulatoryElements && regulatoryElements.length > 0) {
      jsonOutput.regulatory_elements = regulatoryElements.map((element) => {
        const elementFormatted = {};
        if (element.type) elementFormatted.type = element.type;
        if (element.gene) {
          const symbol = element.gene;
          elementFormatted.gene = {
            value_id: geneIndex[symbol],
            label: symbol,
          };
        }
        return elementFormatted;
      });
    }

    // set humanReadable
    setResponseJSON(jsonOutput);
    const humanReadable = outputToReadable(jsonOutput);
    if (humanReadable) setResponseHuman(humanReadable);
  }, [
    components, proteinCoding, rfPreserved, domains, causativeEventKnown, causativeEvent,
    regulatoryElements,
  ]);

  // manage user select/send to clipboard interactions
  const [objectFieldLabel, setObjectFieldLabel] = useState('JSON');
  const [readableFieldLabel, setReadableFieldLabel] = useState('HGVS-like');

  const sleep = (ms) => (
    new Promise((resolve) => setTimeout(resolve, ms))
  );

  const printJSON = (jsonObject) => JSON.stringify(jsonObject, null, 2);

  // Copy the JSON field to clipboard and notify user
  async function handleObjectFieldClick() {
    if (responseJSON && responseJSON !== '') {
      navigator.clipboard.writeText(printJSON(responseJSON));
      setObjectFieldLabel('copied!');
      await sleep(2000);
      setObjectFieldLabel('JSON');
    }
  }

  // Copy readableField to clipboard and notify user
  async function handleReadableFieldClick() {
    if (responseHuman && responseHuman !== '') {
      navigator.clipboard.writeText(responseHuman);
      setReadableFieldLabel('copied!');
      await sleep(2000);
      setReadableFieldLabel('HGVS-like');
    }
  }

  return (
    <>
      <Box p={1}>
        <TextField
          id="response-json"
          label={objectFieldLabel}
          multiline
          variant="outlined"
          InputProps={{
            readOnly: true,
          }}
          value={printJSON(responseJSON)}
          onClick={() => handleObjectFieldClick()}
          style={{ width: 700 }}
          rowsMax={14}
        />
      </Box>
      <Box p={1}>
        <TextField
          id="response-hgvs"
          label={readableFieldLabel}
          multiline
          variant="outlined"
          InputProps={{
            readOnly: true,
          }}
          value={responseHuman}
          onClick={() => handleReadableFieldClick()}
          style={{ width: 700 }}
        />
      </Box>
    </>
  );
};

export default ResponseField;

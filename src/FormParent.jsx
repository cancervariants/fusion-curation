import { React, useState } from 'react';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { makeStyles } from '@material-ui/core/styles';
import FormRadio from './FormRadio';
import CausEventForm from './CausEventForm';
import DomainsForm from './DomainsForm';
import SubmitButton from './SubmitButton';
import ResponseField from './ResponseField';
import ComponentsForm from './ComponentsForm';

const useStyles = makeStyles({
  root: {
    width: '100%',
  },
});

const FormParent = () => {
  // visibility handlers
  const [showRfPreserved, setShowRfPreserved] = useState(false);
  const [showDomains, setShowDomains] = useState(false);
  const [showComponents, setShowComponents] = useState(false);
  const [showCausEvent, setShowCausEvent] = useState(false);
  const [showCausEventInfo, setShowCausEventInfo] = useState(false);
  const [showSubmit, setShowSubmit] = useState(false);
  const [showResponse, setShowResponse] = useState(false);

  // form value handlers
  const [proteinCodingValue, setProteinCodingValue] = useState('');
  const [rfPreserved, setRfPreserved] = useState('');
  const [domains, setDomains] = useState([]);
  // TODO need default value to make controlled/uncontrolled error go away?
  const [components, setComponents] = useState([]); // {id, componentType, componentValues: {}}
  const [causativeEventKnown, setCausativeEventKnown] = useState('');
  const [causativeEvent, setCausativeEvent] = useState('');
  const [responseJSON, setResponseJSON] = useState('{}');
  const [responseHuman, setResponseReadable] = useState('');

  const classes = useStyles();

  /**
   * Recursively hide children
   * @param {string} field name of field (should be the same as the state variable name)
   * @returns null but hides field and children
   */
  const hideChildren = (field) => {
    const dispatch = {
      rfPreserved: 0,
      retainedDomains: 1,
      components: 2,
      causativeEventKnown: 3,
      causativeEvent: 4,
      submit: 4,
      response: 6,
    };

    const precedence = [
      setShowRfPreserved,
      setShowDomains,
      setShowComponents,
      setShowCausEvent,
      setShowCausEventInfo,
      setShowSubmit,
      setShowResponse,
    ];

    precedence.slice(dispatch[field]).forEach((f) => f(false));
  };

  /**
   * Handle result of "protein coding" decision. Make child elements visible or invisible.
   * @param {string} oldValue value of previous selection
   * @param {string} newValue newly selected value
   * @returns nothing, but updates state of child elements accordingly
   */
  const handleSetProteinCoding = (oldValue, newValue) => {
    if (oldValue !== newValue) {
      setProteinCodingValue(newValue);
      if (newValue === 'Yes') {
        hideChildren('components');
        setShowRfPreserved(true);
      } else if (newValue === 'No' || newValue === 'Unknown') {
        hideChildren('rfPreserved');
        setShowComponents(true);
        setShowCausEvent(true);
      }
    }
  };

  /**
   * Handle result of "read frame preserved" decision. Make child elements visible or invisible.
   * @param {string} oldValue value of previous selection
   * @param {string} newValue newly selected value
   * @returns nothing, but updates state of child elements accordingly
   */
  const handleSetRfPreserved = (oldValue, newValue) => {
    if (oldValue !== newValue) {
      setRfPreserved(newValue);
      if (newValue === 'Yes') {
        hideChildren('components');
        setShowDomains(true);
        setShowComponents(true);
        setShowCausEvent(true);
      } else if (newValue === 'No') {
        hideChildren('retainedDomains');
        setShowComponents(true);
        setShowCausEvent(true);
      } else {
        hideChildren('retainedDomains');
        hideChildren('components');
      }
    }
  };

  /**
   * Handle result of "causative event known" decision. Make child elements visible or invisible.
   * @param {string} oldValue value of previous selection
   * @param {string} newValue newly selected value
   * @returns nothing, but updates state of child elements accordingly
   */
  const handleSetCausEvent = (oldValue, newValue) => {
    if (oldValue !== newValue) {
      setCausativeEventKnown(newValue);
      if (newValue === 'Yes') {
        setShowCausEventInfo(true);
        setShowSubmit(true);
      } else if (newValue === 'No') {
        hideChildren('causativeEvent');
        setShowSubmit(true);
      } else {
        hideChildren('causativeEvent');
      }
    }
  };

  /**
   * Transform computable fusion object into human-readable string
   * Uses 'hgvs-like' syntax, eg:
   *  NM_152263.2(EPCAM):exon5::NM_002609.3(MSH2):exon2
   *  NM_162263.2(TPM3):exon8::NM_002609.3(PDGFRB):exon11
   * TODO
   *  * CONSIDERABLY more logical detail is needed due to the change from
   *    'junctions' to 'components'
   *  * 'long form' syntax handling
   * @param {Object} outputJSON fusion object generated by handleSubmit()
   * @return {string} fusion object structured as human-readable string
   */
  const outputToReadable = (outputJSON) => {
    const jsonComponents = outputJSON.components;
    if (jsonComponents.length > 2) {
      const beginning = jsonComponents[0];
      const beginningString = `${beginning.transcript}(${beginning.gene.symbol}):exon${beginning.exon_end}`;

      const end = jsonComponents[jsonComponents.length - 1];
      const endString = `${end.transcript}(${end.gene.symbol}):exon${end.exon_start}`;

      return `${beginningString}::${endString}`;
    }
    return '';
  };

  /**
   * Update state for JSON and human-readable response fields
   * @param {Object} jsonOutput structured output data
   */
  const updateResponses = (jsonOutput) => {
    setResponseJSON(JSON.stringify(jsonOutput, null, 2));
    const humanReadable = outputToReadable(jsonOutput);
    if (humanReadable) setResponseReadable(humanReadable);
    setShowResponse(true);
  };

  /**
   * Get ID for gene name
   * TODO: not working b/c returns asynchronously, after state has already
   * been updated
   * @param {string} symbol gene symbol to retrieve ID for
   * @return {Promise} HGNC concept ID, or empty string if lookup fails
   */
  const getGeneID = (symbol) => {
    const geneID = fetch(`/gene/${symbol}`).then((response) => response.json()).then((geneResponse) => {
      if (geneResponse.warnings) {
        return null;
      }
      const conceptID = geneResponse.concept_id;
      return conceptID;
    });
    return geneID;
  };

  /**
   * Create transcript_region object given user input
   * @param {Object} component object corresponding to given component, as stored in state and
   *  filled out by user
   * @param {*} index location in state array - used to infer some coordinate defaults
   * @returns complete transcript_region object
   */
  const transcriptRegionToJSON = (component, index) => {
    const out = { type: 'transcript_region' };
    const values = component.componentValues;
    if ('transcript' in values) out.transcript = values.transcript;
    if ('gene_symbol' in values) {
      out.gene = {
        symbol: values.gene_symbol,
        id: '<computed>',
      };
    }
    if (values.exon_end !== '') {
      if (index === 0) {
        out.exon_start = 1;
        out.exon_start_genomic = {
          chr: '<computed>', // TODO
          pos: '<computed>', // TODO
        };
      }
      out.exon_end = values.exon_end;
      out.exon_end_genomic = {
        chr: '<computed>', // TODO
        pos: '<computed>', // TODO
      };
    }
    if (values.exon_start !== '') {
      if (index === components.length - 1) {
        out.exon_end = '<computed>';
        out.exon_end_genomic = {
          chr: '<computed>', // TODO
          pos: '<computed>', // TODO
        };
      }
      if (index !== 0) {
        out.exon_start = values.exon_start;
        out.exon_start_genomic = {
          chr: '<computed>', // TODO
          pos: '<computed>', // TODO
        };
      }
    }
    return out;
  };

  /**
   * Create genomic_region object given user input
   * @param {Object} component object corresponding to given component, as stored in state and
   *  filled out by user
   * @returns complete genomic_region object
   */
  const genomicRegionToJSON = (component) => {
    const out = { type: 'genomic_region' };
    const values = component.componentValues;
    if ('chr' in values) out.chr = values.chr;
    if ('strand' in values) out.strand = values.strand;
    if ('start_pos' in values) out.start_pos = values.start_pos;
    if ('end_pos' in values) out.end_pos = values.end_pos;

    return out;
  };

  /**
   * Create linker_sequence object given user input
   * @param {Object} component object corresponding to given component, as stored in state and
   *  filled out by user
   * @returns complete linker_sequence object
   */
  const linkerSequenceToJSON = (comp) => (
    {
      type: 'linker_sequence',
      sequence: comp.componentValues.sequence,
    }
  );

  /**
   * Create gene object given user input
   * @param {Object} component object corresponding to given component, as stored in state and
   *  filled out by user
   * @returns complete gene object
   */
  const geneToJSON = (comp) => (
    {
      type: 'gene',
      symbol: comp.gene,
      id: '<computed>', // TODO compute w/ getGeneID
    }
  );

  /**
   * Call output generation functions upon request by the user
   */
  const handleSubmit = () => {
    const jsonOutput = {};

    if (proteinCodingValue === 'Yes') {
      if (rfPreserved === 'Yes') {
        jsonOutput.r_frame_preserved = true;
        if (domains.length > 0) {
          jsonOutput.domains = domains.map((domain) => {
            const domainObject = {
              status: domain.status,
              name: domain.name,
              id: '<computed>',
              coordinates: '{<computed>}',
            };
            if (domain.gene) {
              domainObject.gene = {
                symbol: domain.gene,
                id: '<computed>',
              };
            }
            return domainObject;
          });
        }
      } else if (rfPreserved === 'No') {
        jsonOutput.r_frame_preserved = false;
      }
    }

    jsonOutput.components = components.map((comp, index) => {
      if (comp.componentType === 'transcript_region') {
        return transcriptRegionToJSON(comp, index);
      }
      if (comp.componentType === 'genomic_region') {
        return genomicRegionToJSON(comp);
      }
      if (comp.componentType === 'linker_sequence') {
        return linkerSequenceToJSON(comp);
      }
      if (comp.componentType === 'gene') {
        return geneToJSON(comp);
      }
      return null;
    });

    if (causativeEventKnown) {
      jsonOutput.causative_event = {
        event_type: causativeEvent,
      };
    }
    updateResponses(jsonOutput);
  };

  return (
    <div className={classes.root}>
      <FormRadio
        name="protein-coding"
        prompt="Is at least one partner protein-coding?"
        state={{
          options: ['Yes', 'No', 'Unknown'],
          state: proteinCodingValue,
          stateFunction: handleSetProteinCoding,
        }}
      />
      {showRfPreserved
        ? (
          <FormRadio
            name="rf-preserved"
            prompt="Is the reading frame predicted to be preserved?"
            state={{
              options: ['Yes', 'No'],
              state: rfPreserved,
              stateFunction: handleSetRfPreserved,
            }}
          />
        )
        : null}
      {showDomains
        ? <DomainsForm domains={domains} setDomains={setDomains} />
        : null}
      {showComponents
        ? (
          <DndProvider backend={HTML5Backend}>
            <ComponentsForm components={components} setComponents={setComponents} />
          </DndProvider>
        )
        : null}
      {showCausEvent
        ? (
          <FormRadio
            name="causative-event"
            prompt="Is causative event known?"
            state={{
              options: ['Yes', 'No'],
              state: causativeEventKnown,
              stateFunction: handleSetCausEvent, // TODO
            }}
          />
        )
        : null}
      {showCausEventInfo
        ? (
          <CausEventForm
            state={causativeEvent}
            handler={setCausativeEvent}
          />
        )
        : null}
      {showSubmit ? <SubmitButton handler={handleSubmit} /> : null}
      {showResponse
        ? <ResponseField jsonValue={responseJSON} readableValue={responseHuman} />
        : null}
    </div>
  );
};

export default FormParent;
